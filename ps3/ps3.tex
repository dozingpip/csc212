1. queue
50 (last)
40
30
20
10 (first)

dequeue
50 

10 (oldest)
20
30
40 (most recent)

pop (40)
pop (30)

next pop is 20

2. pop for queue:
	if (!isempty(queue)){
		int p = queue->head;
		delete queue->head;
		queue->head  = queue->next;
		return p;
	}

push(int p){
	Node *newNode = new Node(i);
	if(head == NULL){
		head = newNode;
	}else{
		head = newNode->prev;
	}
}

3. mystack = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0}
n =20
n+9 +8 +7 +6 +5
n=55
n-4 -3 -2 -1
n= 45
final output: 45

4.
	a) A preorder traversal cannot visit the nodes of a tree in the same order as a postorder traversal.

	b) A preorder and postorder traversal can be in reverse order of each other if the numbers are in ascending or descending order (taking up the maximum height for that number of nodes). There are no other instances of this with the given restrictions because one still goes left to right in the ordering of nodes at the same level of the tree, no matter which direction one is traversing, If any node has more than one child the order wouldn't be reversed in that case.

5. 
	a) If the tree is full, min and max external nodes would be the same at 2^h.
	b) See part a.

6. if height is 2:
	max nodes is 7 because (in max case) the root has 2 nodes, and those 2 nodes can have 2, and if height is 2, that means it can have at max 2 levels of descenance (can only be a grandparent, no further back)
	if height is 3 (for max case):
	root has 2 child nodes, and those children get 2 children nodes, and the children of those get 2 child nodes. The number of children increases by double for every level, nad the extra +1 is for the root node to be included in that level count but it shouldn't be included twice in the final count.

7.   5
    /  \
   3    9
  / \   / \
 1   4 7  14
    /    /  \
    2   11   23
        /    /
       10   18
            / \
           16  21

8.    7
     /  \
    3    9
   / \    \
  2   4   11
         /  \
        10   18
             /
            16

9. max height is 6, min height is 2.
	maximum height tree:
	 1
	  \
	   2
	    \
	     3
	      \
	       4
	        \
	         5
	          \
	           6
	            \
	             7

    minimum height tree:
    	 4
       /  \
      2    6
     / \  / \
    1  3  5  7

10
	a) n-1
	b) log(n+1) -1
	c) 2^(h+1) -1
	d) h+1

11. O(n!) because at the start there is only check 1 node so it wouldn't have to check n times.
Tracing the function given for insertion:
insert (1): it goes here's 1, nothing else here? okay here ya go, a node for you, then insert(2), sees the node given as root is not empty, does the comparison to check less than or equal, passes the start to the right branch (because number to insert is 2) and then since that one has nothing, gets put there, then insert(3) has 2 comparisons to make, and it increases by 1 each time you iterate.

12. function bal_factor(BSTNode *v):
		if(!isempty(v)):
			if(height(v->left) - height(v->right) == 0):
				v->balance = 1
			else:
				v->balance = 0
			bal_factor(v->left)
			bal_factor(v->right)

	function height(BSTNode *v):
		if(isempty(v)): return 0;
		return (1+ Math.max(height(v->left),height(v->right)));